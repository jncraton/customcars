<!DOCTYPE html>
<html lang=en>
<head>
<meta charset=utf-8 /> 
<meta name=viewport content="width=device-width, initial-scale=1"/>
<title>Custom Cars</title>
<style>
* {
  margin:0;
  padding:0;
}
html,body {
  width:90vw;
  height:45vw;
  margin: 0 auto;
}
body { margin-top:2vw; }
canvas {
  width:100%;
  height:100%;
  image-rendering: crisp-edges;
}
</style>
</head>
<body>
<canvas width=360 height=180></canvas>

<script>
const canvas = document.querySelector('canvas')
const ctx = canvas.getContext('2d')
ctx.imageSmoothingEnabled = false

let color = 0
let state = 'edit'
let xpos = 0
let scale = 1

const pixel_size = 18
const im_width = 19
const im_height = 9


let colors = []
// Grays
for (i = 100; i >=0; i-=25) {
  colors.push('hsl(0,0%,' + i + '%)')
}

// Rainbow
for (i = 0; i < 360; i+=15) {
  colors.push('hsl(' + i + ',80%,60%)')
}

const chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_?/:@.~!$&'()*+,="

if (location.hash.length < 50) {
  location.hash = '#' + Array(im_width*im_height).join(0)
}

function getPixel(x,y) {
  x = Math.min(Math.max(0,x), im_width - 1)
  y = Math.min(Math.max(0,y), im_height - 1)
  return chars.indexOf(location.hash[1 + im_width*y + x])
}

function redraw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height)

  if (state=='edit') {
    for (x=0; x<im_width; x++) {
      for (y=0; y<im_height; y++) {
        if (scale == 2 || scale == 3) {
          // Scale3x algorith
          // https://en.wikipedia.org/wiki/Pixel-art_scaling_algorithms
          let a = getPixel(x-1, y-1)
          let b = getPixel(x-0, y-1)
          let c = getPixel(x+1, y-1)
          let d = getPixel(x-1, y-0)
          let e = getPixel(x-0, y-0)
          let f = getPixel(x+1, y-0)
          let g = getPixel(x-1, y+1)
          let h = getPixel(x-0, y+1)
          let i = getPixel(x+1, y+1)

          p = Array(10).fill(e)

          if (d==b && d!=h && b!=f) p[1]=d
          if ((d==b && d!=h && b!=f && e!=c) || (b==f && b!=d && f!=h && e!=a)) p[2]=b
          if (b==f && b!=d && f!=h) p[3]=f
          if ((h==d && h!=f && d!=b && e!=a) || (d==b && d!=h && b!=f && e!=g)) p[4]=d
          if ((b==f && b!=d && f!=h && e!=i) || (f==h && f!=b && h!=d && e!=c)) p[6]=f
          if (h==d && h!=f && d!=b) p[7]=d
          if ((f==h && f!=b && h!=d && e!=g) || (h==d && h!=f && d!=b && e!=i)) p[8]=h
          if (f==h && f!=b && h!=d) p[9]=f

          if (scale == 2) {
            let subpixels = [[p[1], p[3]],
                             [p[7], p[9]]]
          
            for (i = 0; i < 2; i++) {
              for (j = 0; j < 2; j++) {
                ctx.fillStyle = colors[subpixels[j][i]]
                ctx.fillRect(
                  1 + (x+1) * pixel_size + i * pixel_size / 2,
                  (y+0) * pixel_size + j * pixel_size / 2,
                  pixel_size / 2,
                  pixel_size / 2,
                )
              }
            }
          } else if (scale == 3) {
            for (i = 0; i < 3; i++) {
              for (j = 0; j < 3; j++) {
                ctx.fillStyle = colors[p[j*3 + i + 1]]
                ctx.fillRect(
                  1 + (x+1) * pixel_size + i * pixel_size / 3,
                  (y+0) * pixel_size + j * pixel_size / 3,
                  pixel_size / 3,
                  pixel_size / 3,
                )
              }
            }
          }
        } else {
          ctx.fillStyle = colors[getPixel(x,y)]
          ctx.fillRect(
            1 + (x+1) * pixel_size,
            (y+0) * pixel_size,
            pixel_size,
            pixel_size,
          )
        }
      }
    }

    colors.forEach((color, i) => {
      ctx.fillStyle = color
      ctx.strokeStyle = 'hsl(0,0%,30%)'
      ctx.lineWidth = 1
      if (i <= 8) {
        ctx.fillRect(
          0,
          0 + i * pixel_size,
          pixel_size,
          pixel_size,
        )
        ctx.strokeRect(
          .5,
          .5 + i * pixel_size,
          pixel_size,
          pixel_size,
        )
      } else {
        ctx.fillRect(
          (i - 9) * pixel_size,
          canvas.height - pixel_size,
          pixel_size,
          pixel_size,
        )
        ctx.strokeRect(
          .5 + (i - 9) * pixel_size,
          .5 + canvas.height - pixel_size,
          pixel_size,
          pixel_size - 1,
        )
      }
    })
  } else if (state == 'drive') {
    ctx.beginPath()
    ctx.moveTo(0, 100)
    for (x = Math.floor(xpos / 20) * 20; x <= xpos + canvas.width + 20; x+=20) {
      ctx.lineTo(x-xpos, 120 + 
        10*Math.sin(x/(.17 * Math.PI*180)) +
        20*Math.sin(x/(.13 * Math.PI*180)) +
        10*Math.sin(x/(.07 * Math.PI*180)) +
        3*Math.sin(x/(.03 * Math.PI*180))
      )
    }
    ctx.lineTo(canvas.width,canvas.height)
    ctx.lineTo(0,canvas.height)
    ctx.fillStyle='gray'
    ctx.fill()

    xpos += 5
    requestAnimationFrame(redraw)
  }

  // Outer border
  ctx.strokeRect(
    .5,
    .5,
    canvas.width-1,
    canvas.height-1,
  )
}
redraw()

function getCanvasPos(e) {
  let x = (e.clientX - canvas.getBoundingClientRect().x) * canvas.width / canvas.clientWidth
  x = Math.floor(x / pixel_size)
  let y = (e.clientY - canvas.getBoundingClientRect().y) * canvas.height / canvas.clientHeight
  y = Math.floor(y / pixel_size)
  return [x,y]
}

function setPixel(e) {
  let [x, y] = getCanvasPos(e)
  if (x == 0 && e.type != 'mousemove') {
    color = y
  } else if (y == 9 && e.type != 'mousemove') {
    color = x + 9
  } else {
    x -= 1
    if (x >= 0 && x < im_width && y >= 0 && y < im_height) {
      let pixels = location.hash.split('')
      pixels[1 + im_width*y + x] = chars[color]
      location.hash = pixels.join('')
      redraw()
    }
  }
}

canvas.addEventListener('click', setPixel)

let drawing = false

canvas.addEventListener('mousedown', () => drawing=true)
canvas.addEventListener('mouseup', () => drawing=false)
canvas.addEventListener('mousemove', (e) => {
  if (drawing) setPixel(e)
})

// Pick color from drawing
canvas.addEventListener('contextmenu', e => {
  let [x, y] = getCanvasPos(e)
  x-=1
  color = getPixel(x,y)
  e.preventDefault()
})

document.addEventListener('keydown', e => {
  if (e.key == 1) scale = 1
  if (e.key == 2) scale = 2
  if (e.key == 3) scale = 3
  if (e.key == 'Escape') state = 'edit'
  if (e.key == 'd') state = 'drive'
  redraw()
})
</script>

</body>
</html>